{"version":3,"sources":["../keet/src/components/ternaryOps.js","../keet/src/components/templateParse/updateState.js","../keet/src/components/templateParse/valAssign.js","../keet/src/components/templateParse/replaceHandleBars.js","../keet/src/components/genModelList.js","../keet/src/components/conditionalNodes.js","../keet/src/components/componentParse.js","../keet/src/components/templateParse/replaceCommentBlock.js","../keet/src/components/templateParse/addEvent.js","../keet/src/components/templateParse/index.js","../keet/node_modules/set-dom/src/parse-html.js","../keet/node_modules/set-dom/src/index.js","../keet/src/components/parseStr.js","../keet/src/base/mount.js","../keet/src/components/strInterpreter.js","../keet/utils.js","../keet/src/components/genModelTemplate.js","../keet/src/components/genElement.js","../keet/keet.js","../src/app/util.js","../src/app/filter-model.js","../src/app/filter.js","../src/app/todo-model.js","../src/app/todo.js","../src/app/app.js"],"names":["ternaryOps","input","match","t","split","condition","leftHand","rightHand","this","value","test","state","updateState","updateStateList","valAssign","node","replace","withTo","nodeValue","replaceHandleBars","ins","templateParse","isAttr","props","re","ln","length","rep","tnr","isObjectNotation","call","strInterpreter","undefined","render","str","obj","m","genModelTemplate","documentFragment","range","createContextualFragment","firstChild","setAttribute","genModelList","model","modelList","i","listClone","parentNode","updateOfNew","diffOfOld","pNode","equalLength","child","list","oldModel","p","cache","nextSibling","cloneNode","outerHTML","remove","__pristineFragment__","getElementById","id","childNodes","hasOwnProperty","hasAttribute","diff","diffModel","_len","arguments","args","Array","_key","pop","querySelector","replaceChild","insertBefore","lastChild","removeChild","JSON","parse","stringify","getId","checkNodeAvailability","el","bind","catchNode","start","cNode","nodeType","DOCUMENT_ELEMENT_TYPE","isEqualNode","resolveConditionalNodes","conditional","setup","currentNode","fetchFrag","frag","document","createDocumentFragment","conditionalNodesRawEnd","Object","keys","map","c","DOCUMENT_COMMENT_TYPE","appendChild","componentParse","componentStr","component","cacheInit","ID","base","callBatchPoolUpdate","assert","replaceCommentBlock","conditionalRep","modelRep","trim","conditionalRe","conditionalNodes","lookupParentNode","rootNode","getAttribute","addEvent","evtData","isModel","evtName","handler","addEventListener","apply","addEventModel","fn","e","stopPropagation","target","currentTarget","getIndex","ctx","modelInstance","modelObject","type","fragment","instance","inspectAttributes","nodeAttributes","attributes","a","ns","name","localName","removeAttribute","testEventNode","evtStore","obs","push","hasChildNodes","modelRaw","events","addEvt","hasAttributes","check","DOMParserParse","markup","rootName","doc","parser","parseFromString","htmlType","body","documentRootName","documentElement","fallbackParse","supportsInnerHTML","innerHTML","mockHTML","bodyMatch","bodyReg","bodyContent","startBody","index","endBody","slice","xhtmlType","mockBody","setDOM","oldNode","newNode","DOCUMENT_TYPE","DOCUMENT_FRAGMENT_TYPE","parseHTML","nodeName","NODE_MOUNTED","setNode","ELEMENT_TYPE","newPrev","dismount","setAttributes","oldAttributes","newAttributes","b","namespaceURI","getNamedItemNS","removeNamedItemNS","setNamedItemNS","setChildNodes","oldParent","newParent","checkOld","oldKey","checkNew","newKey","foundNode","keyedNodes","extra","getKey","key","KEY","KEY_PREFIX","isIgnored","getCheckSum","CHECKSUM","NaN","IGNORE","mount","dispatch","ev","createEvent","prop","initEvent","defineProperty","dispatchEvent","val","msg","Error","parseStr","stub","addState","setState","componentDidMount","_mount","tempDiv","createElement","_typeof","DOCUMENT_TEXT_TYPE","clearState","res","result","genId","rd","Math","random","toString","minId","componentName","callback","notFound","find","ele","clearInterval","found","fail","setInterval","setTimeout","html","literals","shift","substs","raw","reduce","acc","lit","join","notEqual","inform","exec","createModel","enumerable","configurable","get","set","subscribe","add","concat","_extends","kdata-id","update","updateObj","destroy","destroyObj","filter","RegExp","tmpl","isTernary","len","string","arrProps","fst","sec","some","inr","predicate","attr","createRange","indexOf","window","DOMParser","supportsHTMLType","testClass","testCode","parsed","d","classList","mockDoc","implementation","createHTMLDocument","module","morph","DELAY","x","morpher","console","log","performance","now","genElement","IS_STUB","componentDidUpdate","timer","updateContext","delay","_this","clearTimeout","nextState","stateList","isArray","inVal","l","tr","trace","Keet","indentity","link","componentWillMount","camelCase","s","charAt","toUpperCase","CreateFilterModel","switch","hash","selected","filterModel","from","page","App","_this2","location","history","pushState","_this3","updateUrl","onpopstate","filterApp","_templateObject","CreateModel","clearCompleted","todo","completed","updateAll","checked","todoModel","possibleConstructorReturn","_Keet","addTodo","newTodo","evtTodo","className","editMode","todoList","_templateObject$1","ENTER_KEY","isChecked","count","plural","clearToggle","todoState","_temp","_ret","todos","uncompleted","create","keyCode","title","completeAll","vmodel","_templateObject$2"],"mappings":"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","file":"app.js","sourcesContent":["// function to resolve ternary operation\r\n\r\nconst test = str => str === '\\'\\'' || str === '\"\"' || str === 'null' ? '' : str\r\n\r\nexport default function (input) {\r\n  if (input.match(/([^?]*)\\?([^:]*):([^;]*)|(\\s*=\\s*)[^;]*/g)) {\r\n    let t = input.split('?')\r\n    let condition = t[0]\r\n    let leftHand = t[1].split(':')[0]\r\n    let rightHand = t[1].split(':')[1]\r\n\r\n    // check the condition fulfillment\r\n\r\n    if (this) {\r\n      if (this[condition]) {\r\n        return {\r\n          value: test(leftHand),\r\n          state: condition\r\n        }\r\n      } else {\r\n        return {\r\n          value: test(rightHand),\r\n          state: condition\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  } else return false\r\n}\r\n","export default function (state, updateStateList) {\r\n  if (typeof updateStateList === 'function') updateStateList(state)\r\n}\r\n","export default function (node, value, replace, withTo) {\r\n  value = value.replace(replace, withTo)\r\n  if (node) node.nodeValue = value\r\n}\r\n","import ternaryOps from '../ternaryOps'\r\nimport strInterpreter from '../strInterpreter'\r\nimport updateState from './updateState'\r\nimport valAssign from './valAssign'\r\n\r\nconst re = /{{([^{}]+)}}/g\r\n\r\nexport default function (value, node, ins, updateStateList, templateParse, isAttr) {\r\n  const props = value.match(re)\r\n  let ln = props.length\r\n  let rep\r\n  let tnr\r\n  let isObjectNotation\r\n  \r\n  while (ln) {\r\n    ln--\r\n    rep = props[ln].replace(re, '$1')\r\n    tnr = ternaryOps.call(ins, rep)\r\n    isObjectNotation = strInterpreter(rep)\r\n    if (isObjectNotation) {\r\n      updateState(rep, updateStateList)\r\n      valAssign(node, value, '{{' + rep + '}}', ins[isObjectNotation[0]][isObjectNotation[1]])\r\n    } else {\r\n      if (tnr) {\r\n        updateState(tnr.state, updateStateList)\r\n        if (!isAttr) {\r\n          valAssign(node, value, '{{' + rep + '}}', tnr.value)\r\n        } else {\r\n          return tnr.value\r\n        }\r\n      } else {\r\n        if (ins[rep] !== undefined) {\r\n          updateState(rep, updateStateList)\r\n          if (!isAttr) {\r\n            valAssign(node, value, '{{' + rep + '}}', ins[rep])\r\n          } else {\r\n            return ins[rep]\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { getId, checkNodeAvailability } from '../../utils'\r\nimport genModelTemplate from './genModelTemplate'\r\n\r\n// diffing two array of objects, including object properties differences\r\nconst diff = (fst, sec) =>\r\n  fst.filter(obj =>\r\n    !sec.some(inr => {\r\n      let predicate = true\r\n      for (let attr in inr) {\r\n        if (obj[attr] !== inr[attr]) {\r\n          predicate = false\r\n        }\r\n      }\r\n      return predicate\r\n    })\r\n  )\r\n\r\n// check if browser support createRange\r\nlet range\r\n\r\nif (typeof document.createRange === 'function') {\r\n  range = document.createRange()\r\n}\r\n\r\n// storage for model state\r\nlet cache = {}\r\nlet m\r\nlet documentFragment\r\n\r\nfunction render (str, obj) {\r\n  m = genModelTemplate(str, obj)\r\n  documentFragment = range.createContextualFragment(m)\r\n  documentFragment.firstChild.setAttribute('kdata-id', obj['kdata-id'])\r\n}\r\n\r\nexport default function (node, model, templateParse) {\r\n  let modelList\r\n  let i\r\n  let listClone\r\n  let parentNode\r\n  let updateOfNew\r\n  let diffOfOld\r\n  let pNode\r\n  let equalLength\r\n  let child\r\n  let list\r\n  let str\r\n  let oldModel\r\n  let p\r\n\r\n  cache[model] = cache[model] || {}\r\n\r\n  if (!cache[model].list) {\r\n    cache[model].list = node.nextSibling.cloneNode(true)\r\n  }\r\n  list = cache[model].list\r\n\r\n  if (!cache[model].str) {\r\n    cache[model].str = node.nextSibling.cloneNode(true).outerHTML\r\n    // remove the first prototype node\r\n    node.nextSibling.remove()\r\n    // also remove from pristine node\r\n    p = this.__pristineFragment__.getElementById(node.parentNode.id)\r\n    if (p) p.childNodes[1].remove()\r\n  }\r\n  str = cache[model].str\r\n\r\n  if (this[model] !== undefined && this[model].hasOwnProperty('list')) {\r\n    parentNode = node.parentNode\r\n\r\n    if (range && !parentNode.hasAttribute('data-ignore')) {\r\n      parentNode.setAttribute('data-ignore', '')\r\n    }\r\n\r\n    modelList = this[model].list\r\n\r\n    oldModel = cache[model].oldModel || []\r\n\r\n    // check if current browser doesn't support createRange()\r\n    if (!range) {\r\n      i = 0\r\n      while (i < modelList.length) {\r\n        // fallback to regular node generation handler\r\n        listClone = list.cloneNode(true)\r\n        templateParse(this, null, listClone, modelList[i])\r\n        listClone.setAttribute('kdata-id', modelList[i]['kdata-id'])\r\n        parentNode.insertBefore(listClone, null)\r\n        i++\r\n      }\r\n    } else {\r\n      updateOfNew = diff(modelList, oldModel)\r\n      diffOfOld = diff(oldModel, modelList)\r\n\r\n      const diffModel = function (...args) {\r\n        pNode = args.pop()\r\n        // check if both models are equally in length\r\n        equalLength = oldModel.length === modelList.length\r\n\r\n        // do properties update\r\n        if (equalLength) {\r\n          i = 0\r\n          while (i < updateOfNew.length) {\r\n            child = pNode.querySelector(`[kdata-id=\"${updateOfNew[i]['kdata-id']}\"]`)\r\n            render(str, updateOfNew[i])\r\n            pNode.replaceChild(documentFragment, child)\r\n            i++\r\n          }\r\n        // add new objects\r\n        } else if (updateOfNew.length > 0 && diffOfOld.length === 0) {\r\n          i = 0\r\n          while (i < updateOfNew.length) {\r\n            render(str, updateOfNew[i])\r\n            pNode.insertBefore(documentFragment, pNode.lastChild)\r\n            i++\r\n          }\r\n        // destroy selected objects\r\n        } else if (updateOfNew.length === 0 && diffOfOld.length > 0) {\r\n          i = 0\r\n          while (i < diffOfOld.length) {\r\n            child = pNode.querySelector(`[kdata-id=\"${diffOfOld[i]['kdata-id']}\"]`)\r\n            pNode.removeChild(child)\r\n            i++\r\n          }\r\n        }\r\n        // replace oldModel after diffing\r\n        cache[model].oldModel = JSON.parse(JSON.stringify(modelList))\r\n      }\r\n\r\n      // check existing parentNode in the DOM\r\n      if (parentNode.hasAttribute('id')) {\r\n        pNode = getId(parentNode.id)\r\n\r\n        if (pNode) {\r\n          diffModel.call(this, null, null, pNode)\r\n        } else {\r\n          checkNodeAvailability({ el: parentNode.id }, model, diffModel.bind(this), function () {\r\n            // we cleanup cache on failed search\r\n            cache[model].oldModel = []\r\n          })\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","const conditionalNodesRawEnd = /\\{\\{\\/([^{}]+)\\}\\}/g\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\n\r\nlet cache = {}\r\n\r\n// rebuild the node structure\r\nfunction catchNode (node, start) {\r\n  let cNode\r\n  while (node) {\r\n    cNode = node\r\n    node = node.nextSibling\r\n    if (cNode && cNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      if (cNode.isEqualNode(start)) {\r\n        cNode.remove()\r\n        start = start.nextSibling\r\n      } else {\r\n        catchNode(cNode.firstChild, start)\r\n      }\r\n    } else if (cNode.isEqualNode(start)) {\r\n      cNode.remove()\r\n      start = start.nextSibling\r\n    }\r\n  }\r\n}\r\n\r\nfunction resolveConditionalNodes (node, updateStateList, conditional, templateParse, setup) {\r\n  let currentNode\r\n  let cNode\r\n  let fetchFrag\r\n  let frag = document.createDocumentFragment()\r\n\r\n  if (setup === 'initial' && !cache.hasOwnProperty(conditional)) {\r\n    cNode = node\r\n    while (cNode) {\r\n      currentNode = cNode\r\n      cNode = cNode.nextSibling\r\n      if (currentNode.nodeType !== DOCUMENT_ELEMENT_TYPE && currentNode.nodeValue.match(conditionalNodesRawEnd)) {\r\n        cache[conditional] = cache[conditional] || {}\r\n\r\n        // clean up pristine node\r\n        catchNode(this.__pristineFragment__.firstChild, frag.firstChild)\r\n        // also clean up cache for recursive handlers\r\n        Object.keys(cache).map(c =>\r\n          c !== conditional && catchNode(cache[c].frag.firstChild, frag.firstChild)\r\n        )\r\n\r\n        cache[conditional].frag = frag\r\n        fetchFrag = cache[conditional].frag.cloneNode(true)\r\n\r\n        // resolve recursive conditional handlers as well\r\n        templateParse(this, null, null, null, fetchFrag, 'initial')\r\n\r\n        // update current if conditional is truthy\r\n        if (this[conditional]) {\r\n          currentNode.parentNode.insertBefore(fetchFrag, currentNode)\r\n        }\r\n      } else if (currentNode.nodeType !== DOCUMENT_COMMENT_TYPE) {\r\n        frag.appendChild(currentNode)\r\n      }\r\n    }\r\n  } else {\r\n    if (node.nextSibling.isEqualNode(cache[conditional].frag.firstChild)) return\r\n    fetchFrag = cache[conditional].frag.cloneNode(true)\r\n    if (this[conditional]) {\r\n      node.parentNode.insertBefore(fetchFrag, node.nextSibling)\r\n    } else {\r\n      templateParse(this, null, null, null, fetchFrag, 'update')\r\n    }\r\n  }\r\n}\r\n\r\nexport default resolveConditionalNodes\r\n","import { assert, getId } from '../../utils'\r\n\r\nlet cacheInit = {}\r\n\r\nexport default function (componentStr, node) {\r\n  const component = componentStr.replace('component:', '')\r\n  const c = this[component]\r\n\r\n  if (c !== undefined) {\r\n    // this is for initial component runner\r\n    if (!cacheInit[c.ID]) {\r\n      c.render(true)\r\n      cacheInit[c.ID] = c.base.cloneNode(true)\r\n      node.parentNode.replaceChild(c.base, node)\r\n    } else {\r\n      // we need to reattach event listeners if the node is not available on DOM\r\n      if (!getId(this[component].el)) {\r\n        c.base = c.__pristineFragment__.cloneNode(true)\r\n        c.render(true)\r\n        node.parentNode.replaceChild(c.base, node)\r\n      } else {\r\n        node.parentNode.replaceChild(cacheInit[c.ID].cloneNode(true), node)\r\n      }\r\n    }\r\n    // inform sub-component to update\r\n    c.callBatchPoolUpdate()\r\n  } else {\r\n    assert(false, 'Component ' + component + ' does not exist.')\r\n  }\r\n}\r\n","import genModelList from '../genModelList'\r\nimport conditionalNodes from '../conditionalNodes'\r\nimport updateState from './updateState'\r\nimport componentParse from '../componentParse'\r\n\r\nconst re = /{{([^{}]+)}}/g\r\nconst model = /^model:/g\r\nconst conditionalRe = /^\\?/g\r\nconst component = /^component:([^{}]+)/g\r\n\r\nexport default function (value, node, ins, updateStateList, templateParse, setup) {\r\n  let conditionalRep\r\n  let rep\r\n  let modelRep\r\n  \r\n  if (value.match(re)) {\r\n    rep = value.replace(re, '$1').trim()\r\n    if (rep.match(model) && setup !== 'initial') {\r\n      modelRep = rep.replace('model:', '')\r\n      genModelList.call(this, node, modelRep, templateParse)\r\n    } else if (rep.match(conditionalRe)) {\r\n      conditionalRep = rep.replace('?', '')\r\n      if (ins[conditionalRep] !== undefined) {\r\n        updateState(conditionalRep, updateStateList)\r\n        conditionalNodes.call(this, node, updateStateList, conditionalRep, templateParse, setup)\r\n      }\r\n    } else if (rep.match(component) && setup !== 'initial') {\r\n      componentParse.call(this, rep, node)\r\n    }\r\n  }\r\n}\r\n","import { getId } from '../../../utils'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n\r\nconst re = /{{([^{}]+)}}/g\r\nconst modelRaw = /\\{\\{model:([^{}]+)\\}\\}/g\r\n\r\nfunction lookupParentNode(rootNode, node){\r\n  let cNode\r\n  while(node){\r\n    cNode = node\r\n    node = node.parentNode\r\n    if(cNode.nodeType === DOCUMENT_ELEMENT_TYPE && cNode.hasAttribute('kdata-id')){\r\n      return cNode.getAttribute('kdata-id')\r\n    }\r\n    if(cNode.isEqualNode(rootNode)){\r\n      node = null\r\n    }\r\n  }\r\n}\r\n\r\nconst getIndex = (id, model) => model.list.map(m => m['kdata-id']).indexOf(id)\r\n\r\nfunction addEvent(node, evtData) {\r\n  delete evtData.isModel\r\n  let evtName = Object.keys(evtData)[0]\r\n  let handler = evtData[evtName]\r\n  if (this[handler] !== undefined && typeof this[handler] === 'function') {\r\n    node.addEventListener(evtName, this[handler].bind.apply(this[handler].bind(this), [node]), false)\r\n  }\r\n}\r\n\r\nfunction addEventModel(node, evtData) {\r\n  delete evtData.isModel\r\n  let evtName = Object.keys(evtData)[0]\r\n  let handler = evtData[evtName]\r\n  if (this[handler] !== undefined && typeof this[handler] === 'function') {\r\n    let rep = node.firstChild.nodeValue.replace(re, '$1').trim()\r\n    rep = rep.replace('model:', '')\r\n    let model = this[rep]\r\n    function fn(e) {\r\n      e.stopPropagation()\r\n      if (e.target !== e.currentTarget) {\r\n        let t = lookupParentNode(node, e.target)\r\n        this[handler].apply(this, [model.list[getIndex(t, model)], e.target, e])\r\n      }\r\n    }\r\n    node.addEventListener(evtName, fn.bind(this), false)\r\n  }\r\n}\r\n\r\nexport {\r\n  addEvent,\r\n  addEventModel\r\n}\r\n","import replaceHandleBars from './replaceHandleBars'\r\nimport replaceCommentBlock from './replaceCommentBlock'\r\nimport { addEvent, addEventModel } from './addEvent'\r\nimport { getId } from '../../../utils'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\nconst re = /{{([^{}]+)}}/g\r\nconst modelRaw = /\\{\\{model:([^{}]+)\\}\\}/g\r\n\r\nfunction templateParse (ctx, updateStateList, modelInstance, modelObject, conditional, type) {\r\n  let currentNode\r\n  let fragment\r\n  let instance\r\n\r\n  if (modelObject) {\r\n    instance = modelInstance\r\n  } else if (conditional) {\r\n    instance = conditional.firstChild\r\n  } else {\r\n    fragment = ctx.base\r\n    instance = fragment.firstChild\r\n  }\r\n\r\n  let ins = modelObject || ctx\r\n\r\n  const inspectAttributes = node => {\r\n    let nodeAttributes = node.attributes\r\n    let i = 0\r\n    let a\r\n    let ns\r\n    let name\r\n\r\n    for (i = nodeAttributes.length; i--;) {\r\n      a = nodeAttributes[i]\r\n      name = a.localName\r\n      ns = a.nodeValue\r\n      if (re.test(name)) {\r\n        node.removeAttribute(name)\r\n        name = replaceHandleBars(name, node, ins, null, null, true)\r\n        node.setAttribute(name, ns)\r\n      } else if (re.test(ns)) {\r\n        ns = replaceHandleBars(ns, node, ins, null, null, true)\r\n        if (ns === '') {\r\n          node.removeAttribute(name)\r\n        } else {\r\n          if (name === 'checked') {\r\n            node.setAttribute(name, '')\r\n          } else {\r\n            node.setAttribute(name, ns)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const testEventNode = node => {\r\n    let nodeAttributes = node.attributes\r\n    let i = 0\r\n    let a \r\n    let name \r\n    let value\r\n    let evtName\r\n    let handler\r\n    let evtStore = []\r\n    let obs\r\n    \r\n    while(i < nodeAttributes.length){\r\n      a = nodeAttributes[i]\r\n      name = a.localName\r\n      value = a.nodeValue\r\n      if (/^k-/.test(name)) {\r\n        evtName = name.replace(/^k-/, '')\r\n        handler = value.match(/[a-zA-Z]+(?![^(]*\\))/)[0]\r\n        obs = {}\r\n        obs[evtName] = handler\r\n        obs['isModel'] = false\r\n        evtStore.push(obs)\r\n      }\r\n      i++\r\n    }\r\n    if (obs && node.hasChildNodes() && node.firstChild.nodeType !== DOCUMENT_ELEMENT_TYPE && node.firstChild.nodeValue.match(modelRaw)) {\r\n      obs['isModel'] = true\r\n    }\r\n    return evtStore\r\n  }\r\n\r\n  let events\r\n\r\n  const addEvt = (node, type) => {\r\n    while (node) {\r\n      currentNode = node\r\n      node = node.nextSibling\r\n      if (currentNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n        if (currentNode.hasAttributes() && !getId(currentNode.id)) {\r\n          events = testEventNode(currentNode)\r\n          if(events.length){\r\n            events.map(e =>\r\n              !e.isModel ? addEvent.call(ctx, currentNode, e) : addEventModel.call(ctx, currentNode, e)\r\n            )\r\n          }\r\n        }\r\n        addEvt(currentNode.firstChild, type)\r\n      } \r\n    }\r\n  }\r\n\r\n  const check = (node, type) => {\r\n    while (node) {\r\n      currentNode = node\r\n      node = node.nextSibling\r\n      if (currentNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n        if (type === 'update' && currentNode.hasAttributes()) {\r\n          inspectAttributes(currentNode)\r\n        }\r\n        check(currentNode.firstChild, type)\r\n      } else if (currentNode.nodeValue.match(re)) {\r\n        if (currentNode.nodeType === DOCUMENT_COMMENT_TYPE) {\r\n          replaceCommentBlock.call(ctx, currentNode.nodeValue, currentNode, ins, updateStateList, templateParse, type)\r\n        } else if(type === 'update'){\r\n          replaceHandleBars.call(ctx, currentNode.nodeValue, currentNode, ins, updateStateList, templateParse)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if(type === 'initial' || type === 'update') {\r\n    check(instance, type)\r\n  } else if (type === 'event'){\r\n    addEvt(instance, type)\r\n  }\r\n\r\n}\r\n\r\nexport default templateParse\r\n","'use strict'\nvar parser = window.DOMParser && new window.DOMParser()\nvar documentRootName = 'HTML'\nvar supportsHTMLType = false\nvar supportsInnerHTML = false\nvar htmlType = 'text/html'\nvar xhtmlType = 'application/xhtml+xml'\nvar testClass = 'A'\nvar testCode = '<wbr class=\"' + testClass + '\"/>'\n\ntry {\n  // Check if browser supports text/html DOMParser\n  var parsed = parser.parseFromString(testCode, htmlType).body.firstChild\n  // Some browsers (iOS 9 and Safari 9) lowercase classes for parsed elements\n  // but only when appending to DOM, so use innerHTML instead\n  var d = document.createElement('div')\n  d.appendChild(parsed)\n  if (d.firstChild.classList[0] !== testClass) throw new Error()\n  supportsHTMLType = true\n} catch (e) {}\n\nvar mockDoc = document.implementation.createHTMLDocument('')\nvar mockHTML = mockDoc.documentElement\nvar mockBody = mockDoc.body\ntry {\n  // Check if browser supports documentElement.innerHTML\n  mockHTML.innerHTML += ''\n  supportsInnerHTML = true\n} catch (e) {\n  // Check if browser supports xhtml parsing.\n  parser.parseFromString(testCode, xhtmlType)\n  var bodyReg = /(<body[^>]*>)([\\s\\S]*)<\\/body>/\n}\n\nfunction DOMParserParse (markup, rootName) {\n  var doc = parser.parseFromString(markup, htmlType)\n  // Patch for iOS UIWebView not always returning doc.body synchronously\n  if (!doc.body) { return fallbackParse(markup, rootName) }\n\n  return rootName === documentRootName\n    ? doc.documentElement\n    : doc.body.firstChild\n}\n\nfunction fallbackParse (markup, rootName) {\n  // Fallback to innerHTML for other older browsers.\n  if (rootName === documentRootName) {\n    if (supportsInnerHTML) {\n      mockHTML.innerHTML = markup\n      return mockHTML\n    } else {\n      // IE9 does not support innerhtml at root level.\n      // We get around this by parsing everything except the body as xhtml.\n      var bodyMatch = markup.match(bodyReg)\n      if (bodyMatch) {\n        var bodyContent = bodyMatch[2]\n        var startBody = bodyMatch.index + bodyMatch[1].length\n        var endBody = startBody + bodyContent.length\n        markup = markup.slice(0, startBody) + markup.slice(endBody)\n        mockBody.innerHTML = bodyContent\n      }\n\n      var doc = parser.parseFromString(markup, xhtmlType)\n      var body = doc.body\n      while (mockBody.firstChild) body.appendChild(mockBody.firstChild)\n      return doc.documentElement\n    }\n  } else {\n    mockBody.innerHTML = markup\n    return mockBody.firstChild\n  }\n}\n\n/**\n * Returns the results of a DOMParser as an HTMLElement.\n * (Shims for older browsers).\n */\nmodule.exports = supportsHTMLType\n  ? DOMParserParse\n  : fallbackParse\n","'use strict'\n\nsetDOM.KEY = 'data-key'\nsetDOM.IGNORE = 'data-ignore'\nsetDOM.CHECKSUM = 'data-checksum'\nvar parseHTML = require('./parse-html')\nvar KEY_PREFIX = '_set-dom-'\nvar NODE_MOUNTED = KEY_PREFIX + 'mounted'\nvar ELEMENT_TYPE = 1\nvar DOCUMENT_TYPE = 9\nvar DOCUMENT_FRAGMENT_TYPE = 11\n\n// Expose api.\nmodule.exports = setDOM\n\n/**\n * @description\n * Updates existing dom to match a new dom.\n *\n * @param {Node} oldNode - The html entity to update.\n * @param {String|Node} newNode - The updated html(entity).\n */\nfunction setDOM (oldNode, newNode) {\n  // Ensure a realish dom node is provided.\n  assert(oldNode && oldNode.nodeType, 'You must provide a valid node to update.')\n\n  // Alias document element with document.\n  if (oldNode.nodeType === DOCUMENT_TYPE) oldNode = oldNode.documentElement\n\n  // Document Fragments don't have attributes, so no need to look at checksums, ignored, attributes, or node replacement.\n  if (newNode.nodeType === DOCUMENT_FRAGMENT_TYPE) {\n    // Simply update all children (and subchildren).\n    setChildNodes(oldNode, newNode)\n  } else {\n    // Otherwise we diff the entire old node.\n    setNode(oldNode, typeof newNode === 'string'\n      // If a string was provided we will parse it as dom.\n      ? parseHTML(newNode, oldNode.nodeName)\n      : newNode\n    )\n  }\n\n  // Trigger mount events on initial set.\n  if (!oldNode[NODE_MOUNTED]) {\n    oldNode[NODE_MOUNTED] = true\n    mount(oldNode)\n  }\n}\n\n/**\n * @private\n * @description\n * Updates a specific htmlNode and does whatever it takes to convert it to another one.\n *\n * @param {Node} oldNode - The previous HTMLNode.\n * @param {Node} newNode - The updated HTMLNode.\n */\nfunction setNode (oldNode, newNode) {\n  if (oldNode.nodeType === newNode.nodeType) {\n    // Handle regular element node updates.\n    if (oldNode.nodeType === ELEMENT_TYPE) {\n      // Checks if nodes are equal before diffing.\n      if (isEqualNode(oldNode, newNode)) {\n        // console.trace(oldNode)\n        return\n      }\n\n      // Update all children (and subchildren).\n      setChildNodes(oldNode, newNode)\n\n      // Update the elements attributes / tagName.\n      if (oldNode.nodeName === newNode.nodeName) {\n        // If we have the same nodename then we can directly update the attributes.\n        setAttributes(oldNode.attributes, newNode.attributes)\n      } else {\n        // Otherwise clone the new node to use as the existing node.\n        var newPrev = newNode.cloneNode()\n        // Copy over all existing children from the original node.\n        while (oldNode.firstChild) newPrev.appendChild(oldNode.firstChild)\n        // Replace the original node with the new one with the right tag.\n        oldNode.parentNode.replaceChild(newPrev, oldNode)\n      }\n    } else {\n      // Handle other types of node updates (text/comments/etc).\n      // If both are the same type of node we can update directly.\n      if (oldNode.nodeValue !== newNode.nodeValue) {\n        oldNode.nodeValue = newNode.nodeValue\n      }\n    }\n  } else {\n    // we have to replace the node.\n    oldNode.parentNode.replaceChild(newNode, dismount(oldNode))\n    mount(newNode)\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will update one list of attributes to match another.\n *\n * @param {NamedNodeMap} oldAttributes - The previous attributes.\n * @param {NamedNodeMap} newAttributes - The updated attributes.\n */\nfunction setAttributes (oldAttributes, newAttributes) {\n  var i, a, b, ns, name\n\n  // Remove old attributes.\n  for (i = oldAttributes.length; i--;) {\n    a = oldAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = newAttributes.getNamedItemNS(ns, name)\n    if (!b) oldAttributes.removeNamedItemNS(ns, name)\n  }\n\n  // Set new attributes.\n  for (i = newAttributes.length; i--;) {\n    a = newAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = oldAttributes.getNamedItemNS(ns, name)\n    if (!b) {\n      // Add a new attribute.\n      newAttributes.removeNamedItemNS(ns, name)\n      oldAttributes.setNamedItemNS(a)\n    } else if (b.value !== a.value) {\n      // Update existing attribute.\n      b.value = a.value\n    }\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will nodes childern to match another nodes children.\n *\n * @param {Node} oldParent - The existing parent node.\n * @param {Node} newParent - The new parent node.\n */\nfunction setChildNodes (oldParent, newParent) {\n  var checkOld, oldKey, checkNew, newKey, foundNode, keyedNodes\n  var oldNode = oldParent.firstChild\n  var newNode = newParent.firstChild\n  var extra = 0\n\n  // Extract keyed nodes from previous children and keep track of total count.\n  while (oldNode) {\n    extra++\n    checkOld = oldNode\n    oldKey = getKey(checkOld)\n    oldNode = oldNode.nextSibling\n\n    if (oldKey) {\n      if (!keyedNodes) keyedNodes = {}\n      keyedNodes[oldKey] = checkOld\n    }\n  }\n\n  // Loop over new nodes and perform updates.\n  oldNode = oldParent.firstChild\n  while (newNode) {\n    extra--\n    checkNew = newNode\n    newNode = newNode.nextSibling\n\n    if (keyedNodes && (newKey = getKey(checkNew)) && (foundNode = keyedNodes[newKey])) {\n      delete keyedNodes[newKey]\n      // If we have a key and it existed before we move the previous node to the new position if needed and diff it.\n      if (foundNode !== oldNode) {\n        oldParent.insertBefore(foundNode, oldNode)\n      } else {\n        oldNode = oldNode.nextSibling\n      }\n\n      setNode(foundNode, checkNew)\n    } else if (oldNode) {\n      checkOld = oldNode\n      oldNode = oldNode.nextSibling\n      if (getKey(checkOld)) {\n        // If the old child had a key we skip over it until the end.\n        oldParent.insertBefore(checkNew, checkOld)\n        mount(checkNew)\n      } else {\n        // Otherwise we diff the two non-keyed nodes.\n        setNode(checkOld, checkNew)\n      }\n    } else {\n      // Finally if there was no old node we add the new node.\n      oldParent.appendChild(checkNew)\n      mount(checkNew)\n    }\n  }\n\n  // Remove old keyed nodes.\n  for (oldKey in keyedNodes) {\n    extra--\n    oldParent.removeChild(dismount(keyedNodes[oldKey]))\n  }\n\n  // If we have any remaining unkeyed nodes remove them from the end.\n  while (--extra >= 0) {\n    oldParent.removeChild(dismount(oldParent.lastChild))\n  }\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a key out of an element.\n * Uses 'data-key' if possible and falls back to 'id'.\n *\n * @param {Node} node - The node to get the key for.\n * @return {string|void}\n */\nfunction getKey (node) {\n  if (node.nodeType !== ELEMENT_TYPE) return\n  var key = node.getAttribute(setDOM.KEY) || node.id\n  if (key) return KEY_PREFIX + key\n}\n\n/**\n * Checks if nodes are equal using the following by checking if\n * they are both ignored, have the same checksum, or have the\n * same contents.\n *\n * @param {Node} a - One of the nodes to compare.\n * @param {Node} b - Another node to compare.\n */\nfunction isEqualNode (a, b) {\n  // console.log(a, b, isIgnored(a), isIgnored(b))\n  return (\n    // Check if both nodes are ignored.\n    (isIgnored(a) && isIgnored(b)) ||\n    // Check if both nodes have the same checksum.\n    (getCheckSum(a) === getCheckSum(b)) ||\n    // Fall back to native isEqualNode check.\n    a.isEqualNode(b)\n  )\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a checksum attribute from an element.\n * Uses 'data-checksum' or user specified checksum property.\n *\n * @param {Node} node - The node to get the checksum for.\n * @return {string|NaN}\n */\nfunction getCheckSum (node) {\n  return node.getAttribute(setDOM.CHECKSUM) || NaN\n}\n\n/**\n * @private\n * @description\n * Utility to try to check if an element should be ignored by the algorithm.\n * Uses 'data-ignore' or user specified ignore property.\n *\n * @param {Node} node - The node to check if it should be ignored.\n * @return {boolean}\n */\nfunction isIgnored (node) {\n  return node.getAttribute(setDOM.IGNORE) != null\n}\n\n/**\n * Dispatches a mount event for the given node and children.\n *\n * @param {Node} node - the node to mount.\n * @return {node}\n */\nfunction mount (node) {\n  return dispatch(node, 'mount')\n}\n\n/**\n * Dispatches a dismount event for the given node and children.\n *\n * @param {Node} node - the node to dismount.\n * @return {node}\n */\nfunction dismount (node) {\n  return dispatch(node, 'dismount')\n}\n\n/**\n * Recursively trigger an event for a node and it's children.\n * Only emits events for keyed nodes.\n *\n * @param {Node} node - the initial node.\n * @return {Node}\n */\nfunction dispatch (node, type) {\n  // Trigger event for this element if it has a key.\n  if (getKey(node)) {\n    var ev = document.createEvent('Event')\n    var prop = { value: node }\n    ev.initEvent(type, false, false)\n    Object.defineProperty(ev, 'target', prop)\n    Object.defineProperty(ev, 'srcElement', prop)\n    node.dispatchEvent(ev)\n  }\n\n  // Dispatch to all children.\n  var child = node.firstChild\n  while (child) child = dispatch(child, type).nextSibling\n  return node\n}\n\n/**\n * @private\n * @description\n * Confirm that a value is truthy, throws an error message otherwise.\n *\n * @param {*} val - the val to test.\n * @param {string} msg - the error message on failure.\n * @throws {Error}\n */\nfunction assert (val, msg) {\n  if (!val) throw new Error('set-dom: ' + msg)\n}\n","import templateParse from './templateParse/index'\r\nimport { setState, addState } from './genElement'\r\nimport { getId, assert } from '../../utils'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n\r\nexport default function (stub) {\r\n  templateParse(this, addState, null, null, null, 'initial')\r\n  templateParse(this, addState, null, null, null, 'update')\r\n  templateParse(this, addState, null, null, null, 'event')\r\n  const el = stub || getId(this.el)\r\n  if (el) {\r\n    if (el.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      el.setAttribute('data-ignore', '')\r\n    } else {\r\n      assert(this.base.childNodes.length === 1, 'Sub-component should only has a single rootNode.')\r\n      !this.base.firstChild.hasAttribute('data-ignore') && this.base.firstChild.setAttribute('data-ignore', '')\r\n    }\r\n    // listen to state changes\r\n    setState.call(this)\r\n    // mount fragment to DOM\r\n    if (!stub) {\r\n      el.appendChild(this.base)\r\n    }\r\n\r\n    // since component already rendered, trigger its life-cycle method\r\n    if (this.componentDidMount && typeof this.componentDidMount === 'function') {\r\n      this.componentDidMount()\r\n    }\r\n  } else {\r\n    assert(false, 'No element with id: \"' + this.el + '\" exist.')\r\n  }\r\n}\r\n","import { clearState } from '../components/genElement'\r\n\r\nconst DOCUMENT_FRAGMENT_TYPE = 11\r\nconst DOCUMENT_TEXT_TYPE = 3\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n/**\r\n * @private\r\n * @description\r\n * Mount an instance of string or html elements\r\n *\r\n * @param {String|Object} instance - the html/string \r\n */\r\nexport default function(instance) {\r\n  let base\r\n  let tempDiv\r\n  let frag = document.createDocumentFragment()\r\n  // Before we begin to parse an instance, do a run-down checks\r\n  // to clean up back-tick string which usually has line spacing.\r\n  if (typeof instance === 'string') {\r\n    base = instance.trim().replace(/\\s+/g, ' ')\r\n    tempDiv = document.createElement('div')\r\n    tempDiv.innerHTML = base\r\n    while (tempDiv.firstChild) {\r\n      frag.appendChild(tempDiv.firstChild)\r\n    }\r\n  // If instance is a html element process as html entities\r\n  } else if (typeof instance === 'object' && instance['nodeType']) {\r\n    if (instance['nodeType'] === DOCUMENT_ELEMENT_TYPE) {\r\n      frag.appendChild(instance)\r\n    } else if (instance['nodeType'] === DOCUMENT_FRAGMENT_TYPE) {\r\n      frag = instance\r\n    } else if (instance['nodeType'] === DOCUMENT_TEXT_TYPE) {\r\n      frag.appendChild(instance)\r\n    } else {\r\n      assert(false, 'Unable to parse instance, unknown type.')\r\n    }\r\n  } else {\r\n    assert(false, 'Parameter is not a string or a html element.')\r\n  }\r\n  // we store the pristine instance in __pristineFragment__\r\n  this.__pristineFragment__ = frag.cloneNode(true)\r\n  this.base = frag\r\n\r\n  // cleanup states on mount\r\n  clearState()\r\n  return this\r\n}","export default (str) => {\r\n  let res = str.match(/\\.*\\./g)\r\n  let result\r\n  if (res && res.length > 0) {\r\n    return str.split('.')\r\n  }\r\n  return result\r\n}\r\n","const genId = () => {\r\n  const rd = () => (Math.random()* 1*1e17).toString(36)\r\n  return `KDATA-${rd()}-${rd()}`\r\n}\r\n\r\nconst minId = () => (Math.random()* 1*1e17).toString(36)\r\n\r\nconst getId = id => document.getElementById(id)\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Check a node availability in 100ms, if not found silenty skip the event\r\n * or execute a callback\r\n *\r\n * @param {string} id - the node id\r\n * @param {function} callback - the function to execute on success\r\n * @param {function} notFound - the function to execute on failed\r\n */\r\nconst checkNodeAvailability = (component, componentName, callback, notFound) => {\r\n  let ele = getId(component.el)\r\n  let found = false\r\n  let t\r\n  function find() {\r\n    ele = getId(component.el)\r\n    if (ele) {\r\n      clearInterval(t)\r\n      found = true\r\n      callback(component, componentName, ele)\r\n    }\r\n  }\r\n  function fail() {\r\n    clearInterval(t)\r\n    if (!found && notFound && typeof notFound === 'function') notFound()\r\n  }\r\n  if (ele) return ele\r\n  else {\r\n    t = setInterval(find, 0)\r\n    // ignore finding the node after sometimes\r\n    setTimeout(fail, 5)\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Confirm that a value is truthy, throws an error message otherwise.\r\n *\r\n * @param {*} val - the val to test.\r\n * @param {string} msg - the error message on failure.\r\n * @throws {Error}\r\n */\r\nconst assert = (val, msg) => {\r\n  if (!val) throw new Error('(keet) ' + msg)\r\n}\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Simple html template literals MODIFIED from : http://2ality.com/2015/01/template-strings-html.html\r\n * by Dr. Axel Rauschmayer\r\n * no checking for wrapping in root element\r\n * no strict checking\r\n * remove spacing / indentation\r\n * keep all spacing within html tags\r\n * include handling ${} in the literals\r\n */\r\nconst html = (...args) => {\r\n  const literals = args.shift()\r\n  const substs = args.slice()\r\n\r\n  let result = literals.raw.reduce((acc, lit, i) => acc + substs[i - 1] + lit)\r\n  // remove spacing, indentation from every line\r\n  result = result.split(/\\n+/)\r\n  result = result.map(t => t.trim()).join('')\r\n  return result\r\n}\r\n\r\nconst notEqual = function(a, b){\r\n  return a['kdata-id'] !== b['kdata-id']\r\n}\r\n\r\nconst inform = function(model){\r\n  this.exec && typeof this.exec === 'function' && this.exec(model)\r\n}\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Copy with modification from preact-todomvc. Model constructor with\r\n * registering callback listener in Object.defineProperty. Any modification\r\n * to ```this.list``` instance will subsequently inform all registered listener.\r\n *\r\n * {{model:<myModel>}}<myModelTemplateString>{{/model:<myModel>}}\r\n *\r\n */\r\nclass createModel {\r\n  constructor () {\r\n    this.model = []\r\n    this.exec = null\r\n\r\n    /**\r\n     * @private\r\n     * @description\r\n     * Register callback listener of any changes\r\n     */\r\n    Object.defineProperty(this, 'list', {\r\n      enumerable: false,\r\n      configurable: true,\r\n      get: function () {\r\n        return this.model\r\n      },\r\n      set: function (val) {\r\n        this.model = val\r\n        inform.call(this, this.model)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n * @private\r\n * @description\r\n * Subscribe to the model changes (add/update/destroy)\r\n *\r\n * @param {Object} model - the model including all prototypes\r\n *\r\n */\r\n  subscribe (fn) {\r\n    this.exec = fn\r\n  }\r\n\r\n  /**\r\n * @private\r\n * @description\r\n * Add new object to the model list\r\n *\r\n * @param {Object} obj - new object to add into the model list\r\n *\r\n */\r\n  add (obj) {\r\n    this.list = this.list.concat({ ...obj, 'kdata-id': minId() })\r\n  }\r\n\r\n  /**\r\n * @private\r\n * @description\r\n * Update existing object in the model list\r\n *\r\n * @param {String} lookupId - lookup id property name of the object\r\n * @param {Object} updateObj - the updated properties\r\n *\r\n */\r\n  // update (lookupId, updateObj) {\r\n  //   this.list = this.list.map(obj =>\r\n  //     obj[lookupId] !== updateObj[lookupId] ? obj : Object.assign(obj, updateObj)\r\n  //   )\r\n  // }\r\n  update (updateObj) {\r\n    this.list = this.list.map(obj =>\r\n      notEqual(obj, updateObj) ? obj : updateObj\r\n     // ( obj !== updateObj ? obj : updateObj)\r\n    )\r\n  }\r\n  // this.todos = this.todos.map( todo => (\r\n  //     todo !== todoToToggle ? todo : ({ ...todo, completed: !todo.completed })\r\n  //   ) );\r\n  /**\r\n * @private\r\n * @description\r\n * Removed existing object in the model list\r\n *\r\n * @param {String} lookupId - lookup id property name of the object\r\n * @param {String} objId - unique identifier of the lookup id\r\n *\r\n */\r\n  destroy (destroyObj) {\r\n    this.list = this.list.filter(obj =>\r\n      notEqual(obj, destroyObj)\r\n    )\r\n  }\r\n  // destroy (lookupId, objId) {\r\n  //   this.list = this.list.filter(obj =>\r\n  //     obj[lookupId] !== objId\r\n  //   )\r\n  // }\r\n}\r\n\r\nexport {\r\n  createModel,\r\n  html,\r\n  assert,\r\n  checkNodeAvailability,\r\n  genId,\r\n  getId,\r\n  minId\r\n}\r\n","import ternaryOps from './ternaryOps'\r\n\r\nconst re = new RegExp(/(\\schecked=\")(.*?)(?=\")/g)\r\n\r\nlet tmpl = ''\r\nlet rep\r\nlet isTernary\r\nlet i\r\nlet len\r\nlet match\r\n\r\nexport default (string, obj) => {\r\n  const arrProps = string.match(/{{([^{}]+)}}/g)\r\n  tmpl = string\r\n  for (i = 0, len = arrProps.length; i < len; i++) {\r\n    rep = arrProps[i].replace(/{{([^{}]+)}}/g, '$1')\r\n    isTernary = ternaryOps.call(obj, rep)\r\n    if (isTernary) {\r\n      tmpl = tmpl.replace('{{' + rep + '}}', isTernary.value)\r\n    } else {\r\n      tmpl = tmpl.replace('{{' + rep + '}}', obj[rep])\r\n    }\r\n\r\n    match = tmpl.match(re)\r\n    if (match) {\r\n      if (match[0].length === 17) { tmpl = tmpl.replace(' checked=\"checked\"', ' checked') } else { tmpl = tmpl.replace(' checked=\"\"', '') }\r\n    }\r\n  }\r\n  return tmpl\r\n}\r\n","import templateParse from './templateParse/index'\r\nimport strInterpreter from './strInterpreter'\r\nimport morph from 'set-dom'\r\nimport { getId } from '../../utils'\r\n\r\nmorph.KEY = 'kdata-id'\r\n\r\nconst DELAY = 1\r\nlet el\r\n\r\nlet t\r\nlet x\r\n\r\nconst morpher = function () {\r\n  console.log(this.el, performance.now() - t)\r\n  x = false\r\n  // let t = performance.now()\r\n  el = getId(this.el)\r\n  genElement.call(this)\r\n  // console.log(this.el, performance.now() - t)\r\n  // let tt = performance.now()\r\n  if (el) {\r\n    this.IS_STUB ? morph(el, this.base.firstChild) : morph(el, this.base)\r\n  }\r\n  // console.log(this.el, 'moph',performance.now() - tt)\r\n  // exec life-cycle componentDidUpdate\r\n  if (this.componentDidUpdate && typeof this.componentDidUpdate === 'function') {\r\n    this.componentDidUpdate()\r\n  }\r\n}\r\n\r\nlet timer = {}\r\n\r\nconst updateContext = function (fn, delay) {\r\n  if(!x){\r\n    x = true\r\n    t = performance.now()\r\n  }\r\n  timer[this.ID] = timer[this.ID] || null\r\n  clearTimeout(timer[this.ID])\r\n  timer[this.ID] = setTimeout(() => fn.call(this), delay)\r\n}\r\n\r\nconst nextState = function (i) {\r\n  let state\r\n  let value\r\n  \r\n  if (i < stateList.length) {\r\n    state = stateList[i]\r\n    value = this[state]\r\n\r\n    // if value is undefined, likely has object notation we convert it to array\r\n    if (value === undefined) value = strInterpreter(state)\r\n\r\n    if (value && Array.isArray(value)) {\r\n      // using split object notation as base for state update\r\n      let inVal = this[value[0]][value[1]]\r\n      Object.defineProperty(this[value[0]], value[1], {\r\n        enumerable: false,\r\n        configurable: true,\r\n        get: function () {\r\n          return inVal\r\n        },\r\n        set: function (val) {\r\n          inVal = val\r\n          updateContext.call(this, morpher, DELAY)\r\n        }\r\n      })\r\n    } else {\r\n      // handle parent state update if the state is not an object\r\n      Object.defineProperty(this, state, {\r\n        enumerable: false,\r\n        configurable: true,\r\n        get: function () {\r\n          return value\r\n        },\r\n        set: function (val) {\r\n          value = val\r\n          updateContext.call(this, morpher, DELAY)\r\n        }\r\n      })\r\n    }\r\n    i++\r\n    nextState.call(this, i)\r\n  }\r\n}\r\n\r\nconst setState = function () {\r\n  nextState.call(this, 0)\r\n}\r\n\r\nlet stateList = []\r\n\r\nconst clearState = () => {\r\n  stateList = []\r\n}\r\n\r\nconst addState = state => {\r\n  if (stateList.indexOf(state) === -1) { stateList = stateList.concat(state) }\r\n}\r\n\r\nconst genElement = function () {\r\n  this.base = this.__pristineFragment__.cloneNode(true)\r\n  templateParse(this, addState, null, null, null, 'initial')\r\n  templateParse(this, addState, null, null, null, 'update')\r\n  templateParse(this, addState, null, null, null, 'event')\r\n}\r\n\r\nexport {\r\n  genElement,\r\n  addState,\r\n  setState,\r\n  clearState,\r\n  updateContext,\r\n  morpher\r\n}\r\n","/**\r\n * Keetjs v4.0.0 Alpha release: https://github.com/keetjs/keet.js\r\n * Minimali4.0.0ew layer for the web\r\n *\r\n * <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Keetjs >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n *\r\n * Copyright 2018, Shahrul Nizam Selamat\r\n * Released under the MIT License.\r\n */\r\n\r\nimport parseStr from './src/components/parseStr'\r\nimport { updateContext, morpher } from './src/components/genElement'\r\nimport { getId, genId, assert } from './utils'\r\nimport mount from './src/base/mount'\r\n\r\nwindow.l= console.log.bind(console)\r\nwindow.tr= console.trace.bind(console)\r\n/**\r\n * @description\r\n * The main constructor of Keet\r\n *\r\n * Basic Usage :-\r\n *\r\n *    const App extends Keet {}\r\n *    const app = new App()\r\n *    app.mount('hello world').link('app')\r\n *\r\n */\r\nclass Keet {\r\n\r\n  constructor () {\r\n    this.ID = Keet.indentity\r\n  }\r\n\r\n  // generate ID for the component\r\n  static get indentity(){\r\n    return genId()\r\n  }\r\n\r\n  mount (instance) {\r\n    return mount.call(this, instance)\r\n  }\r\n\r\n  link (id) {\r\n    // The target DOM where the rendering will took place.\r\n    if (!id) assert(id, 'No id is given as parameter.')\r\n    this.el = id\r\n    this.render()\r\n    return this\r\n  }\r\n\r\n  render (stub) {\r\n    // life-cycle method before rendering the component\r\n    if (this.componentWillMount && typeof this.componentWillMount === 'function') {\r\n      this.componentWillMount()\r\n    }\r\n\r\n    // Render this component to the target DOM\r\n    if (stub) {\r\n      this.IS_STUB = true\r\n    }\r\n    parseStr.call(this, stub)\r\n  }\r\n\r\n  callBatchPoolUpdate () {\r\n    // force component to update, if any state / non-state\r\n    // value changed DOM diffing will occur\r\n    updateContext.call(this, morpher, 1)\r\n  }\r\n\r\n  subscribe (fn) {\r\n    this.exec = fn\r\n  }\r\n\r\n  inform (model) {\r\n    this.exec && typeof this.exec === 'function' && this.exec(model)\r\n  }\r\n\r\n}\r\n\r\nexport default Keet\r\n","const store = function(namespace, data) {\r\n  if (arguments.length > 1) {\r\n    return localStorage.setItem(namespace, JSON.stringify(data))\r\n  } else {\r\n    var store = localStorage.getItem(namespace)\r\n    return store && JSON.parse(store) || []\r\n  }\r\n}\r\n\r\nconst camelCase = function(s) {\r\n  return s.charAt(0).toUpperCase() + s.slice(1)\r\n}\r\n\r\nexport {\r\n  store,\r\n  camelCase\r\n}","import { camelCase } from './util'\r\nimport { createModel } from '../../keet/utils'\r\n\r\nclass CreateFilterModel extends createModel {\r\n  switch(hash, obj){\r\n    this.list = this.list.map(filter =>\r\n      filter.hash === hash ? ({ ...filter, ...obj}) : ({ ...filter, ...{ selected: false }})\r\n    )\r\n  }\r\n}\r\n\r\nconst filterModel = new CreateFilterModel()\r\n\r\nArray.from(['all', 'active', 'completed']).map(page =>\r\n\tfilterModel.add({\r\n    hash: `#/${page}`,\r\n    name: camelCase(page),\r\n    selected: false\r\n  })\r\n)\r\n\r\nexport default filterModel","import Keet from '../../keet'\r\nimport { html } from '../../keet/utils'\r\nimport filterModel from './filter-model'\r\n\r\nclass App extends Keet {\r\n  el = 'filters'\r\n  filterModel = filterModel\r\n  componentWillMount() {\r\n    this.filterModel.subscribe(model => this.callBatchPoolUpdate())\r\n    if(window.location.hash == '') {\r\n      window.history.pushState({}, null, '#/all')\r\n    }\r\n  }\r\n  componentDidMount(){\r\n    this.updateUrl(window.location.hash)\r\n    window.onpopstate = () => this.updateUrl(window.location.hash)\r\n  }\r\n  updateUrl(hash) {\r\n    this.filterModel.switch(hash, { selected: true })\r\n  }\r\n}\r\n\r\nconst filterApp = new App()\r\n\r\nlet vmodel = html`\r\n\t<ul id=\"filters\" class=\"filters\">\r\n\t\t<!-- {{model:filterModel}} -->\r\n\t\t<li id=\"{{name}}\" k-click=\"updateUrl({{hash}})\"><a class=\"{{selected?selected:''}}\" href=\"{{hash}}\">{{name}}</a></li>\r\n\t\t<!-- {{/model:filterModel}} -->\r\n\t</ul>\r\n`\r\n\r\nfilterApp.mount(vmodel)\r\n\r\nexport default filterApp","import Keet from '../../keet'\r\nimport { createModel } from '../../keet/utils'\r\n\r\nclass CreateModel extends createModel {\r\n  clearCompleted() {\r\n    this.list = this.list.filter(todo => !todo.completed)\r\n  } \r\n  updateAll(checked){\r\n  \tthis.list = this.list.map(todo => ({ ...todo, completed: checked}))\r\n  }\r\n}\r\n\r\nconst todoModel = new CreateModel()\r\n\r\nexport default todoModel\r\n","import Keet from '../../keet'\r\nimport { html } from '../../keet/utils'\r\nimport todoModel from './todo-model'\r\nlet x\r\nclass App extends Keet {\r\n  el = 'todo-list'\r\n  todoModel = todoModel\r\n  constructor() {\r\n    super()\r\n    this.todoModel.subscribe(model => {\r\n      this.inform(model)\r\n    })\r\n  }\r\n  addTodo(newTodo){\r\n    this.todoModel.add(newTodo)\r\n  }\r\n  evtTodo(obj, target){\r\n    if(target.className === 'toggle')\r\n      this.todoModel.update({ ...obj,  completed: !obj.completed })\r\n    else if(target.className === 'destroy')  \r\n      this.todoModel.destroy(obj)\r\n  }\r\n  editMode(){\r\n    \r\n  }\r\n}\r\n\r\nconst todoList = new App()\r\n\r\nlet vmodel = html`\r\n  <ul id=\"todo-list\" class=\"todo-list\" k-click=\"evtTodo()\">\r\n    <!-- {{model:todoModel}} -->\r\n      <li class=\"{{completed?completed:''}}\">\r\n        <div class=\"view\">\r\n          <input class=\"toggle\" type=\"checkbox\" checked=\"{{completed?checked:''}}\">\r\n          <label>{{title}}</label>\r\n          <button class=\"destroy\"></button>\r\n        </div>\r\n        <input class=\"edit\" value=\"{{title}}\">\r\n      </li>\r\n    <!-- {{/model:todoModel}} -->\r\n  </ul>\r\n`\r\n\r\ntodoList.mount(vmodel)\r\n\r\nexport default todoList","import Keet from '../../keet'\r\nimport { html } from '../../keet/utils'\r\nimport filterApp  from './filter'\r\nimport todoList from './todo'\r\n\r\nconst ENTER_KEY = 13\r\n\r\nlet x\r\n\r\nclass App extends Keet {\r\n  todoList = todoList\r\n  filter = filterApp\r\n  isChecked = false\r\n  count = 0\r\n  plural = ''\r\n  clearToggle = false\r\n  todoState = false\r\n\r\n  componentWillMount() {\r\n    todoList.subscribe(todos => {\r\n      let uncompleted = todos.filter(c => !c.completed)\r\n      let completed = todos.filter(c => c.completed)\r\n      this.clearToggle = completed.length ? true : false\r\n      this.todoState = todos.length ? true : false\r\n      this.plural = uncompleted.length === 1 ? '' : 's'\r\n      this.count = uncompleted.length\r\n      this.isChecked = !uncompleted.length ? true : false\r\n      // l(this)\r\n    })\r\n  }\r\n\r\n  create (e) {\r\n    if(!x){\r\n      x = true\r\n      // window.t = performance.now()\r\n    }\r\n    if(e.keyCode !== ENTER_KEY) return\r\n    let title = e.target.value.trim()\r\n    if(title){\r\n      this.todoList.addTodo({ title, completed: false })\r\n      e.target.value = ''\r\n    }\r\n  }\r\n\r\n  completeAll(){\r\n    this.isChecked = !this.isChecked\r\n    this.todoList.todoModel.updateAll(this.isChecked)\r\n  }\r\n\r\n  clearCompleted() {\r\n    this.todoList.todoModel.clearCompleted()\r\n  }\r\n}\r\n\r\nconst vmodel = html`\r\n  <section class=\"todoapp\">\r\n    <header id=\"header\">\r\n      <h1>todos</h1>\r\n      <input id=\"new-todo\" class=\"new-todo\" k-keydown=\"create()\" placeholder=\"What needs to be done?\" autofocus>\r\n    </header>\r\n    <!-- {{?todoState}} -->\r\n    <section class=\"main\">\r\n      <input id=\"toggle-all\" class=\"toggle-all\" type=\"checkbox\" checked=\"{{isChecked?checked:''}}\" k-click=\"completeAll()\">\r\n      <label for=\"toggle-all\">Mark all as complete</label>\r\n      <!-- {{component:todoList}} -->\r\n    </section>\r\n    <footer class=\"footer\">\r\n      <span class=\"todo-count\">\r\n        <strong>{{count}}</strong> item{{plural}} left\r\n      </span>\r\n      <!-- {{component:filter}} -->\r\n      <!-- {{?clearToggle}} -->\r\n      <button id=\"clear-completed\" k-click=\"clearCompleted()\" class=\"clear-completed\">Clear completed</button>\r\n      <!-- {{/clearToggle}} -->\r\n    </footer>\r\n    <!-- {{/todoState}} -->\r\n  </section>\r\n  <footer class=\"info\">\r\n    <p>Double-click to edit a todo</p>\r\n    <p>Created by <a href=\"https://github.com/syarul\">Shahrul Nizam Selamat</a></p>\r\n    <p>Part of <a href=\"http://todomvc.com\">TodoMVC</a></p>\r\n  </footer>`\r\n\r\nconst app = new App()\r\n\r\napp.mount(vmodel).link('todo')\r\n\r\n// console.log(app)"]}